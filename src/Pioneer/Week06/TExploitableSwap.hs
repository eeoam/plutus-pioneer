{-# LANGUAGE NoImplicitPrelude #-}

module Pioneer.Week06.TExploitableSwap where

import Control.Monad
    ( mapM
    , replicateM
    , unless
    )

import Plutus.Model
    ( Ada (Lovelace)
    , DatumMode (HashDatum)
    , Run
    , Tx
    , ada
    , adaValue
    , defaultBabbage
    , mustFail
    , newUser
    , noErrors
    , sendValue
    , testNoErrors
    , valueAt
    , TypedValidator (TypedValidator)
    , UserSpend
    , currentTimeRad
    , logError
    , payToKey
    , payToScript
    , spend
    , spendScript
    , submitTx
    , toV2
    , userSpend
    , utxoAt
    , validateIn
    , waitUntil
    , initMock
    , runMock
    , FakeCoin (FakeCoin)
    , fakeValue
    )

import Pioneer.Plutus
import Prelude
    ( IO
    , mconcat
    , Ord ((<), (>))
    , (<>)
    , Num ((-))
    , undefined
    )

import Test.Tasty
    ( defaultMain
    , testGroup
    )

import Test.Tasty.QuickCheck as QC
    ( testProperty
    )

import Test.QuickCheck
    ( Property
    , Testable (property)
    , Arbitrary (arbitrary)
    , choose
    , (==>)
    , collect
    )

import Test.QuickCheck.Monadic
    ( assert
    , monadic
    , run)

import Pioneer.Week06.ExploitableSwap qualified as OnChain
import Pioneer.Week06.PatchedSwap     qualified as PatchedOnChain (validator)

instance Testable a => Testable (Run a) where
    property rp = 
        let (a,_) = runMock rp $ initMock defaultBabbage (adaValue 10_000_000)
        in property a


test :: IO () 
test = do
    defaultMain $ do
        testGroup
            "Catch double spend with testing"
            [ good "Normal spending using vulnerable script succeeds" $ normalSpending swapScript
            , good "Double spending using vulnerable script succeeds" $ doubleSpending swapScript
            , good "Normal spending using patched script succeeds   " $ normalSpending patchedSwapScript
            , bad  "Double spending using patched script fails      " $ doubleSpending patchedSwapScript
            ]
    where
        bad msg = good msg . mustFail
        good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"

type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

patchedSwapScript :: HomeworkScript
patchedSwapScript = TypedValidator $ toV2 PatchedOnChain.validator

lockingTx :: HomeworkScript -> PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx script benef price usp val = 
    mconcat
        [ userSpend usp
        , payToScript script (HashDatum (OnChain.DatumSwap benef price)) val
        ]

consumingTx :: HomeworkScript 
            -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend 
            -> TxOutRef -> Value -> Tx
consumingTx script benef price buyer sp2 ref token =
    mconcat
        [ spendScript script ref () (OnChain.DatumSwap benef price)
        , payToKey buyer token
        , payToKey benef $ adaValue price
        , userSpend sp2
        ]

doubleConsumingTx :: HomeworkScript -> PubKeyHash -> Integer
                  -> PubKeyHash -> UserSpend -> TxOutRef -> TxOutRef 
                  -> Value -> Tx
doubleConsumingTx script benef price buyer sp2 ref1 ref2 token =
    mconcat
        [ spendScript script ref1 () (OnChain.DatumSwap benef price)
        , spendScript script ref2 () (OnChain.DatumSwap benef price)
        , payToKey buyer $ token <> token -- Two tokens to buyer
        , payToKey benef $ adaValue price -- Payment for only one token to beneficiary
        , userSpend sp2
        ]

normalSpending :: HomeworkScript -> Run ()
normalSpending script = do
    -- SETUP USERS (one with a super cool token)
    u1 <- newUser (adaValue 1000 <> fakeValue scToken 1)
    u2 <- newUser (adaValue 1000)

    let token = adaValue 1 <> fakeValue scToken 1
    let price = 350
    sp1 <- spend u1 token
    submitTx u1 $ lockingTx script u1 price sp1 token

    utxos <- utxoAt script
    -- logError $ show utxos
    let [(ref, out)] = utxos
    sp2 <- spend u2 (adaValue price)
    submitTx u2 $ consumingTx script u1 price u2 sp2 ref (txOutValue out)

    [v1, v2] <- mapM valueAt [u1, u2]
    let expectedV1 = adaValue 999 <> adaValue price
    let expectedV2 = adaValue (1000 - price) <> token
    unless (v1 == expectedV1 && v2 == expectedV2) $
        logError "Final balances are incorrect"

doubleSpending :: HomeworkScript -> Run ()
doubleSpending script = do
    u1 <- newUser (adaValue 1000 <> fakeValue scToken 2)
    u2 <- newUser (adaValue 1000)

    let token = adaValue 1 <> fakeValue scToken 1
    let price = 350
    sp1 <- spend u1 token
    submitTx u1 $ lockingTx script u1 price sp1 token
    sp1' <- spend u1 token
    submitTx u1 $ lockingTx script u1 price sp1' token

    utxos <- utxoAt script
    let [(ref1, out), (ref2, _)] = utxos
    sp2 <- spend u2 (adaValue price)
    submitTx u2 $ doubleConsumingTx script u1 price u2 sp2 ref1 ref2 (txOutValue out)
    
    [v1, v2] <- mapM valueAt [u1,u2]
    let expectedV1 = adaValue 998 <> adaValue price
    let expectedV2 =  adaValue (1000 - price) <> token <> token
    unless (v1 == expectedV1 && v2 == expectedV2) $
        logError "Final balances are incorrect"

